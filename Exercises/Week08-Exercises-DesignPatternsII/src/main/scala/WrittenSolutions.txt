Solutions to questions requiring written solutions for Exercises on Design Patterns II

1.) (a) Briefly describe the Strategy Design Pattern

    Adding new functionality to a superclass which you want to pass on to its subclasses. You add the functionality in
    an interface which has the functionality and add it as an object within your main subclass. This allows flexibility
    in how the subclasses implement this new behavior.

    (b) When is it appropriate to use the Strategy Design Pattern?

    When you want to add similar functionality to some classes which are part of the same "inheritance" family
    but they will implement this functionality in a unique way, or not at all. So basically, when you want to make a
    change to your superclass without breaking your subclass.


3.) When is it appropriate to use an abstract factory?

    An abstract factory is appropriate to use when you want to hide the creation of objects from the client. Also
    it is appropriate to use when you may be creating new types of objects later on down the road, but don't know
    what these are, so you don't want to have to go back and modify everything.

5.) “In general, the details of object construction, such as instantiating and
    initialising the components that comprise the object, are kept within the
    object, often as part of its constructor.”

    Comment on this statement with reference to modularity and construction bloat.

    If an object uses a lot of construction relationships, that is, it contains/creates many objects of other classes,
    it is susceptible to constructor bloat if those objects are instantiated within the main object's constructor.
     This can cause there to be too many parameters to the constructor and reduces the modularity of your main class.
     If the classes it hold get extended or modified later on, this could mean you have to make changes to your main
     object as well. Using the builder pattern helps to reduce this dependency and keeps your main object modular.

 7.) a. The Facade pattern uses a facade class which holds a list of objects (which often share the same interface
        but have different implementations) and instantiates them upon construction. The Facade is able to call
        upon those objects to perform their functionality, but keeps that "under the hood".

     b. You would do this when you need to decouple the implementation from the client. By providing a facade to
        the client program, you don't need to give the client the details of the performance, nor instatiate
        many objects within the client, as it all happens under the hood.
